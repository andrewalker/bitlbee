diff -Naur bitlbee-20031229/Makefile bitlbee-20031229-daemon/Makefile
--- bitlbee-20031229/Makefile	2003-12-28 15:54:20.000000000 +0100
+++ bitlbee-20031229-daemon/Makefile	2003-12-29 14:47:27.000000000 +0100
@@ -9,7 +9,7 @@
 -include Makefile.settings
 
 # Program variables
-objects = irc.o bitlbee.o user.o nick.o set.o commands.o crypting.o help.o account.o ini.o conf.o
+objects = irc.o bitlbee.o user.o nick.o set.o commands.o crypting.o help.o account.o ini.o conf.o log.o
 subdirs = protocols
 
 # Expansion of variables
diff -Naur bitlbee-20031229/TODO bitlbee-20031229-daemon/TODO
--- bitlbee-20031229/TODO	1970-01-01 01:00:00.000000000 +0100
+++ bitlbee-20031229-daemon/TODO	2003-12-29 14:27:28.000000000 +0100
@@ -0,0 +1,2 @@
+update bitlbee.h, edit patch so it doesn't use try top update 
+bitlbee.c/h. apply patch
diff -Naur bitlbee-20031229/account.c bitlbee-20031229-daemon/account.c
--- bitlbee-20031229/account.c	2003-11-01 00:32:37.000000000 +0100
+++ bitlbee-20031229-daemon/account.c	2003-12-29 14:47:27.000000000 +0100
@@ -33,11 +33,11 @@
 	if( irc->accounts )
 	{
 		for( a = irc->accounts; a->next; a = a->next );
-		a = a->next = malloc( sizeof( account_t ) );
+		a = a->next = bitlbee_alloc( sizeof( account_t ) );
 	}
 	else
 	{
-		irc->accounts = a = malloc( sizeof( account_t ) );
+		irc->accounts = a = bitlbee_alloc( sizeof( account_t ) );
 	}
 	
 	memset( a, 0, sizeof( account_t ) );
@@ -114,7 +114,7 @@
 	
 	cancel_auto_reconnect( a );
 	
-	u = malloc( sizeof( struct aim_user ) );
+	u = bitlbee_alloc( sizeof( struct aim_user ) );
 	memset( u, 0, sizeof( *u ) );
 	u->protocol = a->protocol;
 	strcpy( u->username, a->user );
diff -Naur bitlbee-20031229/bitlbee.c bitlbee-20031229-daemon/bitlbee.c
--- bitlbee-20031229/bitlbee.c	2003-12-28 16:16:58.000000000 +0100
+++ bitlbee-20031229-daemon/bitlbee.c	2003-12-29 15:01:52.000000000 +0100
@@ -32,84 +32,321 @@
 #include <signal.h>
 
 irc_t *IRC;	/* :-( */
-conf_t *conf;
+GList *connection_list = NULL;
+global_t global;	/* Against global namespace pollution */
 
 static void sighandler( int signal );
 
 int main( int argc, char *argv[] )
 {
-	irc_t *irc;
-	struct timeval tv[1];
-	fd_set fds[1];
 	int i;
-	
-	if( 1 )
-	{
-		/* Catch some signals to tell the user what's happening before quitting */
-		struct sigaction sig, old;
-		memset( &sig, 0, sizeof( sig ) );
-		sig.sa_handler = sighandler;
-		sigaction( SIGPIPE, &sig, &old );
-		sig.sa_flags = SA_ONESHOT;
-		sigaction( SIGINT,  &sig, &old );
-		sigaction( SIGILL,  &sig, &old );
-		sigaction( SIGBUS,  &sig, &old );
-		sigaction( SIGFPE,  &sig, &old );
-		sigaction( SIGSEGV, &sig, &old );
-		sigaction( SIGTERM, &sig, &old );
-		sigaction( SIGQUIT, &sig, &old );
-		sigaction( SIGXCPU, &sig, &old );
-	}
-	
-	conf = conf_load( argc, argv );
-	
-	if( !( IRC = irc = irc_new( 0 ) ) )
+	struct sigaction sig, old;
+
+	memset( &global, 9, sizeof( global_t ) );
+
+	global.conf = conf_load( argc, argv );
+	if( global.conf == NULL )
 		return( 1 );
+
+	log_init( );
+ 	nogaim_init( );
 	
-	nogaim_init();
-	set_add( irc, "save_on_quit", "true", set_eval_bool );
-	
-	conf_loaddefaults( irc );
-	
-	while( 1 )
-	{
-		FD_ZERO( fds );
-		FD_SET( irc->fd, fds );
-		tv->tv_sec = 0;
-		tv->tv_usec = 200000;
-		if( ( i = select( irc->fd + 1, fds, NULL, NULL, tv ) ) > 0 )
-		{
-			if( !irc_process( irc ) ) break;
-		}
-		else if( i == -1 ) break;
-		if( irc_userping( irc ) > 0 )
-			break;
-		g_main_iteration( FALSE );
-	}
-	
-	if( irc->status && set_getint( irc, "save_on_quit" ) )
-		if( !bitlbee_save( irc ) )
-			irc_usermsg( irc, "Error while saving settings!" );
-	
-	return( 0 );
-}
+ 	if( global.conf->runmode == RUNMODE_INETD ) { 
+ 		i = bitlbee_inetd_init( );
+		log_message(LOGLVL_INFO, "Bitlbee %s starting in inetd mode.", BITLBEE_VERSION);	
+
+	}
+ 	else if( global.conf->runmode == RUNMODE_DAEMON ) {
+ 		i = bitlbee_daemon_init( );
+		log_message(LOGLVL_INFO, "Bitlbee %s starting in daemon mode.", BITLBEE_VERSION);	
+	}
+	if( i!=0 )
+		return( i );
+ 
+	/* Catch some signals to tell the user what's happening before quitting */
+	memset( &sig, 0, sizeof( sig ) );
+	sig.sa_handler = sighandler;
+	sigaction( SIGPIPE, &sig, &old );
+	sig.sa_flags = SA_ONESHOT;
+	sigaction( SIGINT,  &sig, &old );
+	sigaction( SIGILL,  &sig, &old );
+	sigaction( SIGBUS,  &sig, &old );
+	sigaction( SIGFPE,  &sig, &old );
+	sigaction( SIGSEGV, &sig, &old );
+	sigaction( SIGTERM, &sig, &old );
+	sigaction( SIGQUIT, &sig, &old );
+	sigaction( SIGXCPU, &sig, &old );
 
-int bitlbee_init( irc_t *irc )
-{
 	if( !getuid() || !geteuid() )
-		irc_usermsg( irc, "You're running BitlBee as root. Why?" );
-	
+		log_message( LOGLVL_WARNING, "BitlBee is running under root privileges. Why?" );
 	if( access( CONFIG, F_OK ) != 0 )
-		irc_usermsg( irc, "The configuration directory %s does not exist. Configuration won't be saved.", CONFIG );
+		log_message( LOGLVL_WARNING, "The configuration directory %s does not exist. Configuration won't be saved.", CONFIG );
 	else if( access( CONFIG, R_OK ) != 0 || access( CONFIG, W_OK ) != 0 )
-		irc_usermsg( irc, "Permission problem: Can't read/write from/to %s", CONFIG );
+		log_message( LOGLVL_WARNING, "Permission problem: Can't read/write from/to %s.", CONFIG );
+	if( help_init( &(global.help) ) == NULL )
+		log_message( LOGLVL_WARNING, "Error opening helpfile %s.", HELP_FILE );
+
+  	while( 1 )
+  	{
+ 		if( global.conf->runmode == RUNMODE_INETD )
+ 			i = bitlbee_inetd_main_loop();
+ 		else if( global.conf->runmode == RUNMODE_DAEMON )
+ 			i = bitlbee_daemon_main_loop();
+		if( i == -1 )
+			return( 1 );
+		else if( i != 0 )
+			break;
+  	}
 	
-	if( help_init( irc ) == NULL )
-		irc_usermsg( irc, "Error opening helpfile: %s", HELP_FILE );
+	return( 0 );
+}
+
+int bitlbee_daemon_init(void) {
+	struct sockaddr_in listen_addr;
+ 	int i;
+
+ 	log_link(LOGLVL_ERROR, LOGOUTPUT_SYSLOG);
+	log_link(LOGLVL_WARNING, LOGOUTPUT_SYSLOG);
+
+ 	global.listen_socket = socket( AF_INET, SOCK_STREAM, 0 );
+ 	if( global.listen_socket == -1 ) {  
+ 		log_error("socket");
+ 		return( -1 ); 
+ 	}
+ 	listen_addr.sin_family = AF_INET;         
+ 	listen_addr.sin_port = htons( global.conf->port );     
+ 	listen_addr.sin_addr.s_addr = inet_addr( global.conf->interface );
+
+ 	i=bind( global.listen_socket, ( struct sockaddr * )&listen_addr, 
+ 	       sizeof( struct sockaddr ) );
+ 	if( i == -1 ) {
+ 		log_error( "bind" );
+ 		return( -1 );
+ 	}
+
+ 	i = listen( global.listen_socket, 10 );
+ 	if( i == -1 ) {
+ 		log_error( "listen" );
+ 		return( -1 );
+ 	}
+
+ 	if( !global.conf->nofork ) 	
+ 	{
+ 		i = fork();
+ 		if( i == -1 ) {
+ 			log_error( "fork" );
+ 			return( -1 );
+ 		}
+ 		else if( i!=0 ) 
+ 			exit( 0 );
+		close(0); close(1); close(2);
+		chdir("/");
+ 	}
+ 	return( 0 );
+}
+ 
+int bitlbee_daemon_main_loop( void ) {
+ 	GList *temp;
+ 	struct timeval tv;
+ 	int i, highest, size, new_socket;
+ 	struct sockaddr_in conn_info;
+ 
+ 	FD_ZERO( global.readfds );
+ 	FD_ZERO( global.writefds );
+ 	FD_SET( global.listen_socket, global.readfds );
+ 	FD_SET( global.listen_socket, global.writefds );
+		
+ 	temp = connection_list;
+ 	highest = global.listen_socket;
+ 	
+ 	while( temp != NULL ) 
+ 	{
+ 		FD_SET( ( ( irc_t * )( temp->data ) )->fd, global.readfds );
+ 		FD_SET( ( ( irc_t * )( temp->data ) )->fd, global.writefds );
+ 		if( ( (irc_t * )( temp->data ) )->fd > highest )
+ 			highest = ( ( irc_t * )( temp->data ) )->fd;		
+ 		temp = temp->next;
+ 	} 
+
+ 	tv.tv_sec = 0;
+ 	tv.tv_usec = 200000;
+
+	if( ( i = select( highest + 1, global.readfds, NULL, NULL, &tv ) ) > 0 )
+ 	{
+ 		if( FD_ISSET( global.listen_socket, global.readfds ) ) 
+ 		{
+ 			size = sizeof( struct sockaddr_in );
+ 			new_socket = accept( global.listen_socket, ( struct sockaddr * )&conn_info, 
+ 					     &size );
+ 			log_message(LOGLVL_INFO, "Creating new connection with fd %d.", new_socket);
+			i = bitlbee_connection_create( new_socket );
+			if( i != 1 )
+				return( -1 );
+		}
+ 		temp = connection_list;
+		while( temp != NULL ) 
+ 		{
+ 			if( FD_ISSET( ( ( irc_t *)( temp->data ) )->fd, global.readfds ) )
+ 			{
+ 				IRC = temp->data;
+ 				if( !irc_fill_buffer( IRC ) )
+ 				{
+					log_message(LOGLVL_INFO, "Destroying connection with fd %d.", IRC->fd);
+					temp=bitlbee_connection_destroy( temp );
+ 				} else {
+					if( !irc_process ( IRC ) )
+						temp=bitlbee_connection_destroy( temp );
+ 					if( irc_userping( IRC ) > 0 )
+						temp=bitlbee_connection_destroy( temp );
+				}
+			}
+			if(temp!=NULL)
+ 				temp = temp->next;
+ 		}
+ 	}
+
+	temp = connection_list;
+
+ 	tv.tv_sec = 0;
+ 	tv.tv_usec = 0;
+
+	if( ( i = select( highest + 1, NULL, global.writefds, NULL, &tv ) ) > 0 ) {
+		while( temp != NULL ) 
+ 		{
+ 			if( FD_ISSET( ( ( irc_t *)( temp->data ) )->fd, global.writefds ) )
+				if( !irc_write_buffer(temp->data) )
+					temp = bitlbee_connection_destroy( temp );
+			if(temp!=NULL)
+				temp=temp->next;	
+		}
+	}
+	 
+ 	else if( i == -1 ) {  
+		log_error("select");
+ 		return -1;
+	}
+ 	g_main_iteration( FALSE );
+  	
+ 	return 0;	
+}
+ 
+int bitlbee_inetd_init( void ) {
+ 
+	if( !bitlbee_connection_create( 0 ) )
+		return( 1 );
+
+	IRC=( (irc_t * )( connection_list->data ) );
+
+	log_link(LOGLVL_ERROR, LOGOUTPUT_IRC);
+	log_link(LOGLVL_WARNING, LOGOUTPUT_IRC);
+
+ 	return( 0 );
+}
+ 
+int bitlbee_inetd_main_loop( void ) {
+ 	struct timeval tv[1];
+ 	int i;
+ 	GList *temp;
+ 
+ 	FD_ZERO( global.readfds );
+ 	FD_ZERO( global.writefds );
+ 	FD_SET( IRC->fd, global.readfds );
+ 	FD_SET( IRC->fd, global.writefds );
+ 	tv->tv_sec = 0;
+ 	tv->tv_usec = 200000;
+ 	temp = connection_list;
+ 	
+ 	if( ( i = select( ( ( irc_t * )( temp->data ) )->fd + 1, global.readfds, NULL, NULL, tv ) ) > 0 )
+ 	{
+ 		if( !irc_fill_buffer( ( (irc_t * )( temp->data ) ) ) )
+ 		{ 
+			temp = bitlbee_connection_destroy( temp );
+			return( 1 );
+ 		} else if( !irc_process( ( (irc_t * )( temp->data ) ) ) ) {
+			temp = bitlbee_connection_destroy( temp );
+			return( 1 );
+ 		}
+	}
+
+ 	tv->tv_sec = 0;
+ 	tv->tv_usec = 0;
+
+ 	if( ( i = select( ( ( irc_t * )( temp->data ) )->fd + 1, NULL, global.writefds, NULL, tv ) ) > 0 )
+ 	{
+ 		if( !irc_write_buffer( ( (irc_t * )( temp->data ) ) ) )
+ 		{ 
+ 			if( ( ( irc_t * )( temp->data ) )->status && set_getint( ( (irc_t * )( temp->data ) ), "save_on_quit" ) ) 
+ 				if( !bitlbee_save( ( (irc_t * )( temp->data ) ) ) )
+ 					irc_usermsg( ( (irc_t * )( temp->data ) ), "Error while saving settings!" );
+			return 1;
+ 		}
+ 	}
+ 	else if( i == -1 ) return( -1 );
+	if( irc_userping( temp->data ) > 0 )
+		return( 1 );
+
+ 	g_main_iteration( FALSE );
+  	
+  	return( 0 );
+}
+
+int bitlbee_connection_create( int fd ) {
+	irc_t *newconn;
+
+	newconn = irc_new( fd );
+	if( newconn == NULL )
+		return( 0 );
 	
-	return( 1 );
+  	connection_list = g_list_append( connection_list, newconn );
+	conf_loaddefaults( newconn );
+
+	set_add( newconn, "auto_connect", "true", set_eval_bool );
+	set_add( newconn, "private", "false", set_eval_bool );
+#ifdef DEBUG
+	set_add( newconn, "debug", "true", set_eval_bool );
+#else
+	set_add( newconn, "debug", "false", set_eval_bool );
+#endif
+	set_add( newconn, "to_char", ": ", set_eval_to_char );
+	set_add( newconn, "ops", "both", set_eval_ops );
+	set_add( newconn, "save_on_quit", "1", set_eval_bool );
+	set_add( newconn, "html", "nostrip", NULL );
+	set_add( newconn, "typing_notice", "false", set_eval_bool );
+        set_add( newconn, "away_devoice", "true",  set_eval_away_devoice );
+#ifdef ICONV
+        set_add( newconn, "charset", "none", NULL );  
+#endif
+	set_add( newconn, "handle_unknown", "root", NULL );
+	set_add( newconn, "auto_reconnect", "false", set_eval_bool );
+	set_add( newconn, "reconnect_delay", "300", set_eval_int );
+
+	return( 1 );	
+} 
+
+GList *bitlbee_connection_destroy( GList *node ) {
+	GList *returnval;
+
+	log_message(LOGLVL_INFO, "Destroying connection with fd %d", ( (irc_t * )( node->data ) )->fd); 
+	
+	if( ( (irc_t * )( node->data ) )->status && set_getint( (irc_t *)( node->data ), "save_on_quit" ) ) 
+		if( !bitlbee_save( node->data ) )
+			irc_usermsg( node->data, "Error while saving settings!" );
+
+	FD_CLR( ( (irc_t * )( node->data ) )->fd, global.readfds ); 
+	FD_CLR( ( (irc_t * )( node->data ) )->fd, global.writefds ); 
+	
+	close( ( (irc_t * )( node->data ) )->fd );
+
+	returnval=node->next;
+
+	connection_list=g_list_remove_link(connection_list, node);
+	irc_free(node->data);
+	g_list_free(node);
+
+	return returnval;
 }
 
+
 int bitlbee_load( irc_t *irc, char* password )
 {
 	char s[128];
@@ -311,6 +548,7 @@
 	return( 1 );
 }
 
+
 /* Decode%20a%20file%20name						*/
 void http_decode( char *s )
 {
@@ -372,28 +610,57 @@
 	free( t );
 }
 
+
+void *bitlbee_alloc(size_t size) {
+	void *mem;
+
+	mem=malloc(size);
+	if(mem==NULL) {
+		log_error("malloc");
+		exit(1);
+	}
+	
+	return(mem);
+}
+
+void *bitlbee_realloc(void *oldmem, size_t newsize) {
+	void *newmem;
+
+	newmem=realloc(oldmem, newsize);
+	if(newmem==NULL) {
+		log_error("realloc");
+		exit(1);
+	}
+	
+	return(newmem);
+}
+
+
 static void sighandler( int signal )
 {
 	if( signal == SIGPIPE )
 	{
 		/* SIGPIPE is ignored by Gaim. Looks like we have to do
 		   the same, because it causes some nasty hangs. */
-		if( set_getint( IRC, "debug" ) )
-			irc_usermsg( IRC, "Warning: Caught SIGPIPE, but we probably have to ignore this and pretend nothing happened..." );
+		if( set_getint( NULL, "debug" ) )
+			log_message(LOGLVL_WARNING, "Caught SIGPIPE, but we probably have to ignore this and pretend nothing happened..." );
 		return;
 	}
 	else
 	{
-		irc_write( IRC, "ERROR :Fatal signal received: %d. That's probably a bug.. :-/", signal );
+		log_message(LOGLVL_ERROR, "Fatal signal received: %d. That's probably a bug.", signal );
 		/* exit( 1 ); */
-		raise( signal ); /* Re-raise the signal so the default handler will pick it up, dump core, etc... */
+		raise( signal );
 	}
 }
 
-double gettime()
+double gettime( void )
 {
 	struct timeval time[1];
-	
+
 	gettimeofday( time, 0 );
 	return( (double) time->tv_sec + (double) time->tv_usec / 1000000 );
 }
+
+
+
diff -Naur bitlbee-20031229/bitlbee.h bitlbee-20031229-daemon/bitlbee.h
--- bitlbee-20031229/bitlbee.h	2003-12-29 00:19:18.000000000 +0100
+++ bitlbee-20031229-daemon/bitlbee.h	2003-12-29 14:45:10.000000000 +0100
@@ -32,6 +32,7 @@
 
 #include <fcntl.h>
 #include <unistd.h>
+#include <time.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/time.h>
@@ -43,12 +44,15 @@
 #include <string.h>
 #include <stdarg.h>
 #include <stdio.h>
-#include <glib.h>
+#include <syslog.h>
+#include <errno.h>
 
 #ifndef NO_TCPD
 #include <tcpd.h>
 #endif
 
+#include <glib.h>
+
 #define _( x ) x
 
 #define ROOT_NICK "root"
@@ -73,17 +77,39 @@
 #include "commands.h"
 #include "account.h"
 #include "conf.h"
+#include "log.h"
+#include "ini.h"
+#include "help.h"
+
+typedef struct global_t {
+	fd_set readfds[1];
+	fd_set writefds[1];
+	int listen_socket;
+	help_t *help;
+	conf_t *conf;
+} global_t;
+
+int bitlbee_daemon_main_loop( void );
+int bitlbee_inetd_main_loop( void );
+int bitlbee_daemon_init( void );
+int bitlbee_inetd_init( void );
+
+int bitlbee_connection_create( int fd ); 
+GList *bitlbee_connection_destroy( GList *connection );
 
 int root_command_string( irc_t *irc, user_t *u, char *command );
 int root_command( irc_t *irc, char *command[] );
-int bitlbee_init( irc_t *irc );
 int bitlbee_load( irc_t *irc, char *password );
 int bitlbee_save( irc_t *irc );
+double gettime( void );
 void http_encode( char *s );
 void http_decode( char *s );
-double gettime();
+
+void *bitlbee_alloc(size_t size);
+void *bitlbee_realloc(void *oldmem, size_t newsize);
 
 extern irc_t *IRC;
-extern conf_t *conf;
+extern global_t global;
+extern GList *connection_list;
 
 #endif
diff -Naur bitlbee-20031229/commands.c bitlbee-20031229-daemon/commands.c
--- bitlbee-20031229/commands.c	2003-11-17 14:53:16.000000000 +0100
+++ bitlbee-20031229-daemon/commands.c	2003-12-29 14:47:27.000000000 +0100
@@ -65,8 +65,8 @@
 		strncat( param, cmd[i], sizeof(param) - strlen(param) - 1 );
 	}
 
-	s = help_get( irc, param );
-	if( !s ) s = help_get( irc, "" );
+	s = help_get( &(global.help), param );
+	if( !s ) s = help_get( &(global.help), "" );
 	
 	if( s )
 	{
@@ -110,13 +110,13 @@
 	int checkie;
 	char *str;
 	
-	if( conf->authmode == REGISTERED )
+	if( global.conf->authmode == REGISTERED )
 	{
 		irc_usermsg( irc, "This server does not allow registering new accounts" );
 		return( 0 );
 	}
 	
-	str = (char *) malloc( strlen( irc->nick ) +
+	str = (char *) bitlbee_alloc( strlen( irc->nick ) +
 	      strlen( CONFIG ) +
 	      strlen( ".accounts" ) + 1 );
 	
@@ -150,7 +150,7 @@
 	account_t *a;
 	int i;
 	
-	if( conf->authmode == REGISTERED && irc->status < USTATUS_IDENTIFIED )
+	if( global.conf->authmode == REGISTERED && irc->status < USTATUS_IDENTIFIED )
 	{
 		irc_usermsg( irc, "This server only accepts registered users" );
 		return( 0 );
diff -Naur bitlbee-20031229/conf.c bitlbee-20031229-daemon/conf.c
--- bitlbee-20031229/conf.c	2003-12-26 18:43:18.000000000 +0100
+++ bitlbee-20031229-daemon/conf.c	2003-12-29 14:47:27.000000000 +0100
@@ -39,15 +39,14 @@
 	conf_t *conf;
 	int opt, i;
 	
-	conf = malloc( sizeof( conf_t ) );
-	if( conf==NULL ) { perror( "malloc" ); exit( 1 ); }
+	conf = bitlbee_alloc( sizeof( conf_t ) );
 	memset( conf, 0, sizeof( conf_t ) );
 	
 	conf->interface = "0.0.0.0";
 	conf->port = 6667;
 	conf->nofork = 0;
 	conf->verbose = 0;
-	conf->runmode = INETD;
+	conf->runmode = RUNMODE_INETD;
 	conf->authmode = OPEN;
 	conf->password = NULL;
 	
@@ -73,9 +72,9 @@
 		else if( opt == 'v' )
 			conf->verbose=1;
 		else if( opt == 'c' )
-			conf->runmode=INETD;
+			conf->runmode=RUNMODE_INETD;
 		else if( opt == 'd' )
-			conf->runmode=DAEMON;
+			conf->runmode=RUNMODE_DAEMON;
 		else if( opt == 'h' )
 		{
 			printf( "Usage: bitlbee [-d [-i <interface>] [-p <port>] [-n] [-v]] [-c] \n"
@@ -109,9 +108,9 @@
 			if( strcasecmp( ini->key, "runmode" ) == 0 )
 			{
 				if( strcasecmp( ini->value, "daemon" ) == 0 )
-					conf->runmode = DAEMON;
+					conf->runmode = RUNMODE_DAEMON;
 				else
-					conf->runmode = INETD;
+					conf->runmode = RUNMODE_INETD;
 			}
 			else if( strcasecmp( ini->key, "daemoninterface" ) == 0 )
 			{
diff -Naur bitlbee-20031229/conf.h bitlbee-20031229-daemon/conf.h
--- bitlbee-20031229/conf.h	2003-12-26 18:42:43.000000000 +0100
+++ bitlbee-20031229-daemon/conf.h	2003-12-29 14:47:27.000000000 +0100
@@ -26,7 +26,7 @@
 #ifndef __CONF_H
 #define __CONF_H
 
-typedef enum runmode { DAEMON, INETD } runmode_t;
+typedef enum runmode { RUNMODE_DAEMON, RUNMODE_INETD } runmode_t;
 typedef enum authmode { OPEN, CLOSED, REGISTERED } authmode_t;
 
 typedef struct conf
@@ -35,7 +35,6 @@
 	signed int port;
 	int nofork;
 	int verbose;
-	int listen_socket;
 	runmode_t runmode;
 	authmode_t authmode;
 	char *password;
diff -Naur bitlbee-20031229/crypting.c bitlbee-20031229-daemon/crypting.c
--- bitlbee-20031229/crypting.c	2003-10-25 00:32:50.000000000 +0200
+++ bitlbee-20031229-daemon/crypting.c	2003-12-29 14:47:27.000000000 +0100
@@ -112,7 +112,7 @@
 	
 	if (irc->password == NULL) return (NULL);
 	
-	rv = (char *)malloc (33);
+	rv = (char *)bitlbee_alloc (33);
 	memset (rv, 0, 33);
 	
 	md5_init (&md5state);
@@ -134,7 +134,7 @@
 	
 	if (irc->password == NULL) return (NULL);
 	
-	rv = (char *)malloc (strlen (line) + 1);
+	rv = (char *)bitlbee_alloc (strlen (line) + 1);
 	memset (rv, '\0', strlen (line) + 1);
 	
 	i = j = 0;
@@ -159,7 +159,7 @@
 	
 	if (irc->password == NULL) return (NULL);
 	
-	rv = (char *)malloc (strlen (line) + 1);
+	rv = (char *)bitlbee_alloc (strlen (line) + 1);
 	memset (rv, '\0', strlen (line) + 1);
 	
 	i = j = 0;
diff -Naur bitlbee-20031229/help.c bitlbee-20031229-daemon/help.c
--- bitlbee-20031229/help.c	2003-10-15 02:13:38.000000000 +0200
+++ bitlbee-20031229-daemon/help.c	2003-12-29 14:47:27.000000000 +0100
@@ -24,36 +24,35 @@
 */
 
 #include "bitlbee.h"
-#include "help.h"
 
 #define BUFSIZE 1100
 
-help_t *help_init( irc_t *irc )
+help_t *help_init( help_t **help )
 {
 	int i, buflen = 0;
-	help_t *h; //, *h2;
+	help_t *h;
 	char *s, *t;
 	time_t mtime;
 	struct stat stat[1];
 	
-	irc->help = h = malloc( sizeof( help_t ) );
+	*help = h = bitlbee_alloc( sizeof( help_t ) );
 	memset( h, 0, sizeof( help_t ) );
 	h->fd = open( HELP_FILE, O_RDONLY );
 	
 	if( h->fd == -1 )
 	{
 		free( h );
-		return( irc->help = NULL );
+		return( *help = NULL );
 	}
 	
 	if( fstat( h->fd, stat ) != 0 )
 	{
 		free( h );
-		return( irc->help = NULL );
+		return( *help = NULL );
 	}
 	mtime = stat->st_mtime;
 	
-	s = malloc( BUFSIZE + 1 );
+	s = bitlbee_alloc( BUFSIZE + 1 );
 	s[BUFSIZE] = 0;
 	
 	while( ( ( i = read( h->fd, s + buflen, BUFSIZE - buflen ) ) > 0 ) ||
@@ -64,8 +63,8 @@
 		if( !( t = strstr( s, "\n%\n" ) ) || s[0] != '?' )
 		{
 			/* FIXME: Clean up */
-//			help_close( irc->help );
-			irc->help = NULL;
+//			help_close( *help );
+			*help = NULL;
 			free( s );
 			return( NULL );
 		}
@@ -73,14 +72,14 @@
 		
 		if( h->string )
 		{
-			h = h->next = malloc( sizeof( help_t ) );
+			h = h->next = bitlbee_alloc( sizeof( help_t ) );
 			memset( h, 0, sizeof( help_t ) );
 		}
-		h->string = malloc( i );
+		h->string = bitlbee_alloc( i );
 		
 		strncpy( h->string, s + 1, i - 1 );
 		h->string[i-1] = 0;
-		h->fd = ((help_t *)irc->help)->fd;
+		h->fd = (*help)->fd;
 		h->offset.file_offset = lseek( h->fd, 0, SEEK_CUR ) - buflen + i + 1;
 		h->length = t - s - i - 1;
 		h->mtime = mtime;
@@ -88,22 +87,23 @@
 		buflen -= ( t + 3 - s );
 		t = strdup( t + 3 );
 		free( s );
-		s = realloc( t, BUFSIZE + 1 );
+		s = bitlbee_realloc( t, BUFSIZE + 1 );
 		s[BUFSIZE] = 0;
 	}
 	
 	free( s );
 	
-	return( irc->help );
+	return( *help );
 }
 
-char *help_get( irc_t *irc, char *string )
+char *help_get( help_t **help, char *string )
 {
-	help_t *h;
 	time_t mtime;
 	struct stat stat[1];
-	
-	h = irc->help;
+	help_t *h;
+
+	h=*help;	
+
 	while( h )
 	{
 		if( strcasecmp( h->string, string ) == 0 ) break;
@@ -111,19 +111,20 @@
 	}
 	if( h )
 	{
-		char *s = malloc( h->length + 1 );
+		char *s = bitlbee_alloc( h->length + 1 );
 		
 		if( fstat( h->fd, stat ) != 0 )
 		{
 			free( h );
-			return( irc->help = NULL );
+			*help=NULL;
+			return( NULL );
 		}
 		mtime = stat->st_mtime;
 		
-		if( mtime > h->mtime )
+		if( mtime > h->mtime ) {
 			return( NULL );
-//			return( strdup( "Help file changed during this session. Please restart to get help back." ) );
-		
+			return( strdup( "Help file changed during this session. Please restart to get help back." ) );
+		}
 		s[h->length] = 0;
 		if( h->fd > 0 )
 		{
diff -Naur bitlbee-20031229/help.h bitlbee-20031229-daemon/help.h
--- bitlbee-20031229/help.h	2003-04-28 19:18:55.000000000 +0200
+++ bitlbee-20031229-daemon/help.h	2003-12-29 14:47:27.000000000 +0100
@@ -23,13 +23,16 @@
   Suite 330, Boston, MA  02111-1307  USA
 */
 
+#ifndef _HELP_H
+#define _HELP_H
+
 typedef union
 {
 	off_t file_offset;
 	char *mem_offset;
 } help_off_t;
 
-typedef struct
+typedef struct help_t
 {
 	int fd;
 	time_t mtime;
@@ -39,6 +42,7 @@
 	void *next;
 } help_t;
 
-help_t *help_init( irc_t *irc );
-char *help_get( irc_t *irc, char *string );
+help_t *help_init( help_t **help );
+char *help_get( help_t **help, char *string );
 
+#endif
diff -Naur bitlbee-20031229/ini.c bitlbee-20031229-daemon/ini.c
--- bitlbee-20031229/ini.c	2003-06-27 14:25:03.000000000 +0200
+++ bitlbee-20031229-daemon/ini.c	2003-12-29 14:47:27.000000000 +0100
@@ -23,15 +23,11 @@
   Suite 330, Boston, MA  02111-1307  USA
 */
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "ini.h"
+#include "bitlbee.h"
 
 ini_t *ini_open( char *file )
 {
-	ini_t *ini = (ini_t *) malloc( sizeof( ini_t ) );
+	ini_t *ini = (ini_t *) bitlbee_alloc( sizeof( ini_t ) );
 	
 	memset( ini, 0, sizeof( ini_t ) );
 	if( ( ini->fp = fopen( file, "r" ) ) == NULL )
diff -Naur bitlbee-20031229/ini.h bitlbee-20031229-daemon/ini.h
--- bitlbee-20031229/ini.h	2003-06-27 14:29:18.000000000 +0200
+++ bitlbee-20031229-daemon/ini.h	2003-12-29 14:47:27.000000000 +0100
@@ -23,6 +23,9 @@
   Suite 330, Boston, MA  02111-1307  USA
 */
 
+#ifndef _INI_H
+#define _INI_H
+
 #ifndef MAX_STRING
 #define MAX_STRING 128
 #endif
@@ -40,3 +43,5 @@
 ini_t *ini_open( char *file );
 int ini_read( ini_t *file );
 void ini_close( ini_t *file );
+
+#endif
diff -Naur bitlbee-20031229/irc.c bitlbee-20031229-daemon/irc.c
--- bitlbee-20031229/irc.c	2003-12-28 17:21:24.000000000 +0100
+++ bitlbee-20031229-daemon/irc.c	2003-12-29 15:00:25.000000000 +0100
@@ -26,12 +26,10 @@
 #include "bitlbee.h"
 #include "crypting.h"
 
-static char *set_eval_to_char( irc_t *irc, set_t *set, char *value );
-static char *set_eval_ops( irc_t *irc, set_t *set, char *value );
-
 irc_t *irc_new( int fd )
 {
-	irc_t *irc = malloc( sizeof( irc_t ) );
+	irc_t *irc = bitlbee_alloc( sizeof( irc_t ) );
+
 	struct sockaddr_in sock[1];
 	struct hostent *peer;
 	int i;
@@ -46,8 +44,8 @@
 	irc->channel = strdup( ROOT_CHAN );
 	
 	i = sizeof( *sock );
-	if( conf->hostname )
-		irc->myhost = strdup( conf->hostname );
+	if( global.conf->hostname )
+		irc->myhost = strdup( global.conf->hostname );
 	else if( getsockname( irc->fd, (struct sockaddr*) sock, &i ) == 0 )
 		if( ( peer = gethostbyaddr( (char*) &sock->sin_addr, sizeof(sock->sin_addr), AF_INET ) ) )
 			irc->myhost = strdup( peer->h_name );
@@ -57,11 +55,13 @@
 		if( ( peer = gethostbyaddr( (char*) &sock->sin_addr, sizeof(sock->sin_addr), AF_INET ) ) )
 			irc->host = strdup( peer->h_name );
 #ifndef NO_TCPD
-		i = hosts_ctl( "bitlbee", irc->host?irc->host:STRING_UNKNOWN, inet_ntoa( sock->sin_addr ), STRING_UNKNOWN );
+		if( global.conf->run_mode == 1)
+			i = hosts_ctl( "bitlbee", irc->host?irc->host:STRING_UNKNOWN, inet_ntoa( sock->sin_addr ), STRING_UNKNOWN );
 	}
 	else
 	{
-		i = 0;
+		if( global.conf->run_mode == 1)
+			i = 0;
 #endif
 	}
 	
@@ -78,108 +78,339 @@
 		return( NULL );
 	}
 #endif
-	
-	set_add( irc, "auto_connect", "true", set_eval_bool );
-	set_add( irc, "private", "false", set_eval_bool );
-#ifdef DEBUG
-	set_add( irc, "debug", "true", set_eval_bool );
-#else
-	set_add( irc, "debug", "false", set_eval_bool );
-#endif
-	set_add( irc, "to_char", ": ", set_eval_to_char );
-	set_add( irc, "ops", "both", set_eval_ops );
-	
+
 	irc_write( irc, ":%s NOTICE AUTH :%s", irc->myhost, "BitlBee-IRCd initialized, please go on" );
 	
 	return( irc );
 }
 
+/* Because we have no garbage collection, this is quite annoying */
+void irc_free( irc_t *irc ) {
+	query_t *query, *querytmp;
+	account_t *account, *accounttmp;
+	user_t *user, *usertmp; 
+	nick_t *nick, *nicktmp;
+	help_t *helpnode, *helpnodetmp; 
+	set_t *setnode, *setnodetmp; 
+
+	if(irc!=NULL) {
+		if(irc->sendbuffer!=NULL)
+			free(irc->sendbuffer);	
+		if(irc->readbuffer!=NULL)
+			free(irc->readbuffer);	
+	
+		if(irc->nick!=NULL);
+			free(irc->nick);	
+		if(irc->user!=NULL);
+			free(irc->user);	
+		if(irc->host!=NULL);
+			free(irc->host);	
+		if(irc->realname!=NULL);
+			free(irc->realname);	
+		if(irc->password!=NULL);
+			free(irc->password);
+		
+		if(irc->myhost!=NULL)
+			free(irc->myhost);
+		if(irc->mynick!=NULL)
+			free(irc->mynick);
+
+		if(irc->channel!=NULL)
+			free(irc->channel);
+
+		if(irc->queries!=NULL) {
+			query=irc->queries;
+			while(query!=NULL) {
+				if(query->question!=NULL)
+					free(query->question);
+				querytmp=query;
+				query=query->next;
+				free(querytmp);
+			}
+		}
+		if(irc->accounts!=NULL) {
+			account=irc->accounts;
+			while(account!=NULL) {
+				if(account->user!=NULL)
+					free(account->user);
+				if(account->pass!=NULL)
+					free(account->pass);
+				accounttmp=account;
+				account=account->next;
+				free(accounttmp);
+			}		
+		}
+
+		if(irc->users!=NULL) {
+			user=irc->users;
+			while(user!=NULL) {
+				if(user->nick!=NULL)
+					free(user->nick);
+				if(user->away!=NULL)
+					free(user->away);
+				if(user->handle!=NULL)
+					free(user->handle);
+				usertmp=user;	
+				user=user->next;
+				free(usertmp);
+			}
+		}
+		if(irc->nicks!=NULL) {
+			nick=irc->nicks;
+			while(nick!=NULL) {
+				if(nick->nick!=NULL)
+					free(nick->nick);
+				if(nick->handle!=NULL)
+					free(nick->handle);
+				nicktmp=nick;	
+				nick=nick->next;
+				free(nicktmp);
+			}
+		}
+		if(irc->help!=NULL) {
+			helpnode=irc->help;
+			while(helpnode!=NULL) {
+				if(helpnode->string!=NULL)
+					free(helpnode->string);
+				helpnodetmp=helpnode;	
+				helpnode=helpnode->next;
+				free(helpnodetmp);
+			}
+		}
+		if(irc->set!=NULL) {
+			setnode=irc->set;
+			while(setnode!=NULL) {
+				if(setnode->key!=NULL)
+					free(setnode->key);
+				if(setnode->def!=NULL)
+					free(setnode->def);
+				if(setnode->value!=NULL)
+					free(setnode->value);
+				setnodetmp=setnode;	
+				setnode=setnode->next;
+				free(setnodetmp);
+			}
+		}
+		free(irc);				
+	}	
+}
+
 int irc_process( irc_t *irc )
 {
-	char *line;
-	int bytes = 0, size = 256, st;
-	struct timeval tv[1];
-	fd_set fds[1];
+	char **lines, *temp;	
+	int i;
+
+	if( irc->readbuffer != NULL ) {
+		lines = irc_tokenize(irc->readbuffer );
+		for( i = 0; *lines[i] != '\0'; i++ ) {
+			if( lines[i+1] == NULL ) {
+				temp = strdup( lines[i] );
+				free( irc->readbuffer );
+				irc->readbuffer = temp;
+				i++;
+				break;
+			}			
+			if (!irc_process_line(irc, lines[i]))
+				return 0;		
+		}
+		if(lines[i]!=NULL) {
+			free(irc->readbuffer);
+			irc->readbuffer=NULL;	
+		}
+		free( lines );
+	}
+	return 1;	
+}
+
+char **irc_tokenize( char *buffer ) {
+	int i, j;
+	char **lines;
+
+	/* Count the number of elements we're gonna need. */
+	for(i=0, j=1; buffer[i]!='\0'; i++ ) {
+		if(buffer[i]=='\n' )
+			if(buffer[i+1]!='\r' && buffer[i+1]!='\n');
+				j++;
+	}
 	
-	line = malloc( size );
+	/* Allocate j+1 elements. */
+	lines=bitlbee_alloc((j+1)*sizeof(char *));
 	
-	FD_ZERO( fds );
-	FD_SET( irc->fd, fds );
+	/* NULL terminate our list. */ 
+	lines[j]=NULL;
+	
+	lines[0]=buffer;
+	
+	/* Split the buffer in several strings, using \r\n as our seperator, where \r is optional.
+	 * Although this is not in the RFC, some braindead ircds (newnet's) use this, so some clients might too. 
+	 */
+	for( i=0, j=0; buffer[i]!='\0'; i++) {
+		if(buffer[i]=='\n') {
+			buffer[i]='\0';
+
+			/* We dont want to read 1 byte before our buffer
+			 * and (in rare cases) generate a SIGSEGV.
+			 */
+			if(i!=0)
+				if(buffer[i-1]=='\r')
+					buffer[i-1]='\0';
+			if(buffer[i+1]!='\r'&& buffer[i+1]!='\n')
+				lines[++j]=buffer+i+1;
+		}
+	}
+
+	return(lines);
+}
+
+int irc_fill_buffer( irc_t *irc ) 
+{
+	int st;
+	struct timeval tv[1];
+	fd_set readfds[1];
+	char line[256];	
+
+	FD_ZERO( readfds );
+	FD_SET( irc->fd, readfds );
+
 	tv->tv_sec = 0;
 	tv->tv_usec = 0;
 	
-	while( select( irc->fd + 1, fds, NULL, NULL, tv ) > 0 )
+	while( select( irc->fd + 1, readfds, NULL, NULL, tv ) > 0 )
 	{
-		st = read( irc->fd, line + bytes, size - bytes );
+		st = read( irc->fd, line, 255 );
 		if( st <= 0 )
-		{
-			free( line );
 			return( 0 );
+		line[st]='\0';
+		if( irc->readbuffer == NULL ) 
+			irc->readbuffer = strdup( line );
+		else 
+		{
+			irc->readbuffer = bitlbee_realloc(irc->readbuffer, strlen( irc->readbuffer ) + strlen ( line ) + 1 );
+			strcpy( ( irc->readbuffer+strlen( irc->readbuffer ) ), line ); 
 		}
+	}
+	return 1;
+}
+
+int irc_write_buffer( irc_t *irc ) 
+{
+	fd_set writefds[1];
+	struct timeval tv[1];
+	int st, size;
+	char *temp;
+	time_t newtime;
+
+	tv->tv_sec=0;
+	tv->tv_usec=0;
+
+	FD_ZERO( writefds );
+	FD_SET( irc->fd, writefds );
+
+	newtime=time(NULL);
+	
+	if((newtime-irc->oldtime)>FLOOD_SEND_INTERVAL) {
+		irc->sentbytes=0;
+		irc->oldtime=newtime;
+	}
+
+	while( select( irc->fd + 1, NULL, writefds, NULL, tv ) > 0 ) {
+		if( irc->sendbuffer == NULL)
+			break;
+		
+		size=strlen(irc->sendbuffer);		
 		
-		bytes += st;
-		if( bytes == size )
+		if((FLOOD_SEND_BYTES-irc->sentbytes)>size)
+			st = write( irc->fd, irc->sendbuffer, size );
+		else		
+			st = write( irc->fd, irc->sendbuffer, (FLOOD_SEND_BYTES-irc->sentbytes) );
+
+		if( st < 0 )
+			return 0;
+		else if( st==0 )
+			return 1;		
+
+		irc->sentbytes+=st;
+
+		if( st == size ) 
 		{
-			size *= 2;
-			line = realloc( line, size );
+			free( irc->sendbuffer );
+			irc->sendbuffer = NULL;
+			if(irc->quit)
+				return( 0 );
+		}
+		else {
+			temp = bitlbee_alloc( size - st + 1 );
+			strcpy(temp, (irc->sendbuffer+st) );
+			free( irc->sendbuffer );
+			irc->sendbuffer = temp;
 		}
 	}
-	
-	if( bytes > 0 )
-		st = irc_process_string( irc, line, bytes );
-	else
-		st = 1;
-	
-	free( line );
-	return( st );
+	return(1);
 }
 
-int irc_process_string( irc_t *irc, char *line, int bytes )
+int irc_process_line( irc_t *irc, char *line )
 {
-	char *cmd[IRC_MAX_ARGS+1];
-	int i, arg, dosplit;
+	int i, j;
+	char **cmd;
 	
-	/* Split it all into separate lines and split the commands as well, then execute them */
+	/* Move the line pointer to the start of the command, skipping spaces and the optional prefix. */
+	if(line[0]==':') {
+		for(i=0; line[i]!=32; i++);
+		line=line+i;
+	}
+	for(i=0; line[i]==32; i++);
+	line=line+i;
+
+	/* If we're already at the end of the line, return. If not, we're going to need at least one element. */
+	if(line[0]=='\0')
+		return 1;
+	else
+		j=1;	
 	
-	memset( cmd, 0, sizeof( cmd ) );
+	/* Count the number of char **cmd elements we're going to need. */	
+	for(i=0; line[i]!='\0'; i++) {
+		if((line[i]==32) && (line[i+1]!=32) && (line[i+1]!='\0') && (line[i+1]!=':'))		
+			j++;
+		else if((line[i]==':') && (line[i+1]!='\0') && (line[i-1]==32)) {
+			j++;
+			break;
+		}
+			
+	}	
+
+	/* Allocate the space we need. */
+	cmd=bitlbee_alloc((j+1)*sizeof(char *));
+	cmd[j]=NULL;
 	
-	cmd[0] = line;
-	arg = dosplit = 1;
-	for( i = 0; ( i < bytes ) && ( arg < IRC_MAX_ARGS ); i ++ )
-	{
-		if( line[i] == ' ' && dosplit )
-		{
-			line[i] = 0;
-			cmd[arg] = line + i + 1;
-			if( *cmd[arg] == ':' )
-			{
-				cmd[arg] ++;
-				dosplit = 0;
-				arg ++;
-			}
-			else if( *cmd[arg] && *cmd[arg] != '\r' && *cmd[arg] != '\n' && *cmd[arg] != ' ' )
-				arg ++;
-		}
-		else if( line[i] == '\r' || line[i] == '\n' )
-		{
-			cmd[arg] = NULL;
-			line[i] = 0;
-			if( !irc_exec( irc, cmd ) ) return( 0 );
-			if( ( ( i + 1 ) < bytes ) && ( line[i+1] == '\n' ) ) i ++;
-			memset( cmd, 0, sizeof( cmd ) );
-			cmd[0] = line + i + 1;
-			arg = dosplit = 1;
+	/* Do the actual line splitting, format is:
+	 * Input: "PRIVMSG #bitlbee :foo bar"
+	 * Output: cmd[0]=="PRIVMSG", cmd[1]=="#bitlbee", cmd[2]=="foo bar", cmd[3]==NULL
+	 */
+
+	cmd[0]=line;
+	for(i=0, j=0; line[i]!='\0'; i++) {
+		if((line[i]==32)) {
+			line[i]='\0';
+			if((line[i+1]!=32) && (line[i+1]!='\0') && (line[i+1]!=':')) 		
+				cmd[++j]=line+i+1;
+		}
+		else if((line[i]==':') && (line[i+1]!='\0') && (line[i-1]=='\0')) {
+			cmd[++j]=line+i+1;
+			break;
 		}
 	}
 	
-	return( 1 );
+	i=irc_exec(irc, cmd);
+	free(cmd);
+
+	return(i);	
 }
 
 int irc_exec( irc_t *irc, char **cmd )
 {	
 	int i;
-	
-	if( conf->authmode == CLOSED && irc->status < USTATUS_AUTHORIZED )
+
+	if( (global.conf)->authmode == CLOSED && irc->status < USTATUS_AUTHORIZED )
 	{
 		if( strcasecmp( cmd[0], "PASS" ) == 0 )
 		{
@@ -187,7 +418,7 @@
 			{
 				irc_reply( irc, 461, "%s :Need more parameters", cmd[0] );
 			}
-			else if( strcmp( cmd[1], conf->password ) == 0 )
+			else if( strcmp( cmd[1], (global.conf)->password ) == 0 )
 			{
 				irc->status = USTATUS_AUTHORIZED;
 			}
@@ -509,7 +740,7 @@
 	return( 1 );
 }
 
-int irc_reply( irc_t *irc, int code, char *format, ... )
+void irc_reply( irc_t *irc, int code, char *format, ... )
 {
 	char text[IRC_MAX_LINE];
 	va_list params;
@@ -517,7 +748,9 @@
 	va_start( params, format );
 	vsnprintf( text, IRC_MAX_LINE, format, params );
 	va_end( params );
-	return( irc_write( irc, ":%s %03d %s %s", irc->myhost, code, irc->nick?irc->nick:"*", text ) );
+	irc_write( irc, ":%s %03d %s %s", irc->myhost, code, irc->nick?irc->nick:"*", text );
+	
+	return;
 }
 
 int irc_usermsg( irc_t *irc, char *format, ... )
@@ -537,32 +770,70 @@
 	return( irc_msgfrom( irc, u->nick, text ) );
 }
 
-int irc_write( irc_t *irc, char *format, ... )
+void irc_write( irc_t *irc, char *format, ... ) 
 {
-	char line[IRC_MAX_LINE];
 	va_list params;
-	int n, start = 0;
-	
+
 	va_start( params, format );
-	vsnprintf( line, IRC_MAX_LINE - 3, format, params );
+	irc_vawrite( irc, format, params );	
 	va_end( params );
+
+	return;
+
+}
+void irc_vawrite( irc_t *irc, char *format, va_list params )
+{
+	int size;
+	char line[IRC_MAX_LINE];
+	
+	if( irc->quit )
+		return;
+
+	vsnprintf( line, IRC_MAX_LINE - 3, format, params );
+
 	strcat( line, "\r\n" );
+
+	if( irc->sendbuffer != NULL ) {
+		size=strlen( irc->sendbuffer ) + strlen( line );
+		if( size > FLOOD_SEND_MAXBUFFER ) {
+			/* Die flooder, die! >:) */
+
+			free(irc->sendbuffer);
+			
+			/* We need the \r\n at the start because else we might append our string to a half
+			 * sent line. A bit hackish, but it works.
+			 */
+			irc->sendbuffer=strdup("\r\nERROR :Sendq Exceeded\r\n");
+			irc->quit=1; 
 	
-	while( line[start] )
-	{
-		n = write( irc->fd, line + start, strlen( line + start ) );
-		if( n <= 0 )
-		{
-			/* PANIC! But we can't tell the user through IRC,
-			   that'd probably cause an infinite loop.. */
-			return( 0 );
+			return;
 		}
-		start += n;
+		irc->sendbuffer=bitlbee_realloc( irc->sendbuffer, size + 1 );
+		strcpy( ( irc->sendbuffer + strlen( irc->sendbuffer ) ), line );
 	}
-	
-	return( 1 );
+	else 
+		irc->sendbuffer = strdup(line);	
+
+	return;
 }
 
+void irc_write_all( char *format, ... )
+{
+	va_list params;
+	GList *temp;	
+
+	va_start( params, format );
+
+	temp = connection_list;
+	while( temp!=NULL ) {
+		irc_vawrite( temp->data, format, params );
+		temp = temp->next;
+	}
+
+	va_end( params );
+	return;
+} 
+
 void irc_names( irc_t *irc, char *channel )
 {
 	user_t *u = irc->users;
@@ -682,8 +953,6 @@
 //	u->send_handler = msg_echo;
 	irc_spawn( irc, u );
 	
-	bitlbee_init( irc );
-	
 	irc_usermsg( irc, "Welcome to the BitlBee gateway!\n\nIf you've never used BitlBee before, please do read the help information using the help command. Lots of FAQ's are answered there." );
 	
 	irc->status = USTATUS_LOGGED_IN;
@@ -1012,7 +1281,7 @@
 	if( !u->private && nick_cmp( u->nick, irc->mynick ) != 0 )
 	{
 		int len = strlen( irc->nick) + 3;
-		prefix = malloc( len );
+		prefix = bitlbee_alloc( len );
 		snprintf( prefix, len, "%s%s", irc->nick, set_getstr( irc, "to_char" ) );
 		prefix[len-1] = 0;
 	}
@@ -1034,48 +1303,6 @@
 		return( 0 );
 }
 
-static char *set_eval_to_char( irc_t *irc, set_t *set, char *value )
-{
-	char *s = malloc( 3 );
-	
-	if( *value == ' ' )
-		strcpy( s, " " );
-	else
-		sprintf( s, "%c ", *value );
-	
-	return( s );
-}
-
-static char *set_eval_ops( irc_t *irc, set_t *set, char *value )
-{
-	if( strcasecmp( value, "user" ) == 0 )
-	{
-		irc_write( irc, ":%s!%s@%s MODE %s %s %s %s", irc->mynick, irc->mynick, irc->myhost,
-		                                              irc->channel, "+o-o", irc->nick, irc->mynick );
-		return( value );
-	}
-	else if( strcasecmp( value, "root" ) == 0 )
-	{
-		irc_write( irc, ":%s!%s@%s MODE %s %s %s %s", irc->mynick, irc->mynick, irc->myhost,
-		                                              irc->channel, "-o+o", irc->nick, irc->mynick );
-		return( value );
-	}
-	else if( strcasecmp( value, "both" ) == 0 )
-	{
-		irc_write( irc, ":%s!%s@%s MODE %s %s %s %s", irc->mynick, irc->mynick, irc->myhost,
-		                                              irc->channel, "+oo", irc->nick, irc->mynick );
-		return( value );
-	}
-	else if( strcasecmp( value, "none" ) == 0 )
-	{
-		irc_write( irc, ":%s!%s@%s MODE %s %s %s %s", irc->mynick, irc->mynick, irc->myhost,
-		                                              irc->channel, "-oo", irc->nick, irc->mynick );
-		return( value );
-	}
-	
-	return( NULL );
-}
-
 /* Returns 0 if everything seems to be okay, a number >0 when there was a
    timeout. The number returned is the number of seconds we received no
    pongs from the user. When not connected yet, we don't ping but drop the
diff -Naur bitlbee-20031229/irc.h bitlbee-20031229-daemon/irc.h
--- bitlbee-20031229/irc.h	2003-12-26 19:00:02.000000000 +0100
+++ bitlbee-20031229-daemon/irc.h	2003-12-29 14:50:46.000000000 +0100
@@ -34,6 +34,10 @@
 #define IRC_PING_TIMEOUT 300
 #define IRC_PING_STRING "PinglBee"
 
+#define FLOOD_SEND_INTERVAL 10
+#define FLOOD_SEND_BYTES (1024*5)
+#define FLOOD_SEND_MAXBUFFER (1024*5)
+
 #define UMODES "ais"
 #define CMODES "nt"
 #define CMODE "nt"
@@ -67,7 +71,13 @@
 	irc_status_t status;
 	double last_pong;
 	int pinging;
-	
+	char *sendbuffer;
+	char *readbuffer;
+	int quit;
+
+	int sentbytes;
+	time_t oldtime;
+
 	char *nick;
 	char *user;
 	char *host;
@@ -81,7 +91,7 @@
 
 	char *channel;
 	int c_id;
-	
+
 	char private;
 	query_t *queries;
 	struct account *accounts;
@@ -96,14 +106,20 @@
 #include "nick.h"
 
 irc_t *irc_new( int fd );
+void irc_free( irc_t *irc );
 
 int irc_exec( irc_t *irc, char **cmd );
 int irc_process( irc_t *irc );
-int irc_process_string( irc_t *irc, char *line, int bytes );
-
-int irc_write( irc_t *irc, char *format, ... );
-int irc_reply( irc_t *irc, int code, char *format, ... );
+int irc_write_buffer( irc_t *irc );
+int irc_fill_buffer( irc_t *irc );
+int irc_process_line( irc_t *irc, char *line );
+
+void irc_vawrite( irc_t *irc, char *format, va_list params );
+void irc_write( irc_t *irc, char *format, ... );
+void irc_write_all( char *format, ... );
+void irc_reply( irc_t *irc, int code, char *format, ... );
 int irc_usermsg( irc_t *irc, char *format, ... );
+char **irc_tokenize( char *buffer );
 
 void irc_login( irc_t *irc );
 void irc_motd( irc_t *irc );
diff -Naur bitlbee-20031229/log.c bitlbee-20031229-daemon/log.c
--- bitlbee-20031229/log.c	1970-01-01 01:00:00.000000000 +0100
+++ bitlbee-20031229-daemon/log.c	2003-12-29 14:47:28.000000000 +0100
@@ -0,0 +1,197 @@
+  /********************************************************************\
+  * BitlBee -- An IRC to other IM-networks gateway                     *
+  *                                                                    *
+  * Copyright 2002-2003 Wilmer van der Gaast and others                *
+  \********************************************************************/
+
+/* Logging services for the bee 			*/
+
+/*
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License with
+  the Debian GNU/Linux distribution in /usr/share/common-licenses/GPL;
+  if not, write to the Free Software Foundation, Inc., 59 Temple Place,
+  Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "bitlbee.h"
+
+static log_t logoutput;
+
+static void log_null(int level, char *logmessage);
+static void log_irc(int level, char *logmessage);
+static void log_syslog(int level, char *logmessage);
+static void log_console(int level, char *logmessage);
+
+void log_init(void) {
+	openlog("bitlbee", LOG_PID, LOG_DAEMON);	
+
+	logoutput.informational=&log_null;
+	logoutput.warning=&log_null;
+	logoutput.error=&log_null;
+#ifdef DEBUG
+	logoutput.debug=&log_null;
+#endif
+
+	return;
+}
+
+void log_link(int level, int output) {
+	/* I know it's ugly, but it works and I didn't feel like messing with pointer to function pointers */
+
+	if(level==LOGLVL_INFO) {
+		if(output==LOGOUTPUT_NULL)
+			logoutput.informational=&log_null;	
+		else if(output==LOGOUTPUT_IRC)
+			logoutput.informational=&log_irc;	
+		else if(output==LOGOUTPUT_SYSLOG)
+			logoutput.informational=&log_syslog;	
+		else if(output==LOGOUTPUT_CONSOLE) 
+			logoutput.informational=&log_console;	
+	}
+	else if(level==LOGLVL_WARNING) {
+		if(output==LOGOUTPUT_NULL)
+			logoutput.warning=&log_null;
+		else if(output==LOGOUTPUT_IRC)
+			logoutput.warning=&log_irc;
+		else if(output==LOGOUTPUT_SYSLOG)
+			logoutput.warning=&log_syslog;
+		else if(output==LOGOUTPUT_CONSOLE)
+			logoutput.warning=&log_console;
+	}
+	else if(level==LOGLVL_ERROR) {
+		if(output==LOGOUTPUT_NULL)
+			logoutput.error=&log_null;
+		else if(output==LOGOUTPUT_IRC)
+			logoutput.error=&log_irc;
+		else if(output==LOGOUTPUT_SYSLOG)
+			logoutput.error=&log_syslog;
+		else if(output==LOGOUTPUT_CONSOLE)
+			logoutput.error=&log_console;
+	}
+#ifdef DEBUG
+	else if(level==LOGLVL_DEBUG) {
+		if(output==LOGOUTPUT_NULL)
+			logoutput.debug=&log_null;
+		else if(output==LOGOUTPUT_IRC)
+			logoutput.debug=&log_irc;
+		else if(output==LOGOUTPUT_SYSLOG)
+			logoutput.debug=&log_syslog;
+		else if(output==LOGOUTPUT_CONSOLE)
+			logoutput.debug=&log_console;
+	}
+#endif
+	return;	
+
+}
+
+void log_message(int level, char *message, ... ) {
+
+	va_list ap;
+	char *msgstring;
+
+	va_start(ap, message);
+	msgstring=my_vasprintf(message, ap);
+	va_end(ap);
+
+	if(level==LOGLVL_INFO)
+		(*(logoutput.informational))(level, msgstring);
+	if(level==LOGLVL_WARNING) 
+		(*(logoutput.warning))(level, msgstring);
+	if(level==LOGLVL_ERROR)
+		(*(logoutput.error))(level, msgstring);
+#ifdef DEBUG
+	if(level==LOGLVL_DEBUG)
+		(*(logoutput.debug))(level, msgstring);
+#endif
+
+	free(msgstring);
+	
+	return;
+}
+
+void log_error(char *functionname) {
+	log_message(LOGLVL_ERROR, "%s: %s", functionname, strerror(errno));
+	
+	return;
+}
+
+static void log_null(int level, char *message) {
+	return;
+}
+
+static void log_irc(int level, char *message) {
+	if(level==LOGLVL_ERROR)
+		irc_write_all("ERROR :Error: %s", message);
+	if(level==LOGLVL_WARNING)
+		irc_write_all("ERROR :Warning: %s", message);
+	if(level==LOGLVL_INFO)
+		irc_write_all("ERROR :Informational: %s", message);	
+#ifdef DEBUG
+	if(level==LOGLVL_DEBUG)
+		irc_write_all("ERROR :Debug: %s", message);	
+#endif	
+
+	return;
+}
+
+static void log_syslog(int level, char *message) {
+	if(level==LOGLVL_ERROR)
+		syslog(LOG_ERR, message);
+	if(level==LOGLVL_WARNING)
+		syslog(LOG_WARNING, message);
+	if(level==LOGLVL_INFO)
+		syslog(LOG_INFO, message);
+#ifdef DEBUG
+	if(level==LOGLVL_DEBUG)
+		syslog(LOG_DEBUG, message);
+#endif
+	return;
+}
+
+static void log_console(int level, char *message) {
+	if(level==LOGLVL_ERROR)
+		fprintf(stderr, "Error: %s\n", message);
+	if(level==LOGLVL_WARNING)
+		fprintf(stderr, "Warning: %s\n", message);
+	if(level==LOGLVL_INFO)
+		fprintf(stdout, "Informational: %s\n", message);
+#ifdef DEBUG
+	if(level==LOGLVL_DEBUG)
+		fprintf(stdout, "Debug: %s\n", message);
+#endif
+	return;
+}
+
+/* From the printf manpage with changes. Let's just hope SCO doesn't 
+ * sue me now. ;) 
+ */
+char *my_vasprintf(const char *fmt, va_list ap) {
+	/* Guess we need no more than 100 bytes. */
+	int n, size = 100;
+	char *p;
+	p = bitlbee_alloc (size);
+	while (1) {
+		/* Try to print in the allocated space. */
+		n = vsnprintf (p, size, fmt, ap);
+		/* If that worked, return the string. */
+		if (n > -1 && n < size)
+			return p;
+		/* Else try again with more space. */
+		if (n > -1)    /* glibc 2.1 */
+			size = n+1; /* precisely what is needed */
+		else           /* glibc 2.0 */
+			size *= 2;  /* twice the old size */
+		p=bitlbee_realloc(p, size);
+	}
+}
+
diff -Naur bitlbee-20031229/log.h bitlbee-20031229-daemon/log.h
--- bitlbee-20031229/log.h	1970-01-01 01:00:00.000000000 +0100
+++ bitlbee-20031229-daemon/log.h	2003-12-29 14:47:28.000000000 +0100
@@ -0,0 +1,61 @@
+  /********************************************************************\
+  * BitlBee -- An IRC to other IM-networks gateway                     *
+  *                                                                    *
+  * Copyright 2002-2003 Wilmer van der Gaast and others                *
+  \********************************************************************/
+
+/* Logging services for the bee                               */
+
+/*
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License with
+  the Debian GNU/Linux distribution in /usr/share/common-licenses/GPL;
+  if not, write to the Free Software Foundation, Inc., 59 Temple Place,
+  Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _LOG_H
+#define _LOG_H
+
+typedef enum {
+	LOGLVL_INFO,
+	LOGLVL_WARNING,
+	LOGLVL_ERROR,
+#ifdef DEBUG
+	LOGLVL_DEBUG,
+#endif
+} loglvl_t;
+
+typedef enum {
+	LOGOUTPUT_NULL,
+	LOGOUTPUT_IRC,
+	LOGOUTPUT_SYSLOG,
+	LOGOUTPUT_CONSOLE,
+} logoutput_t;
+
+typedef struct log_t {
+	void (*error)(int level, char *logmessage);
+	void (*warning)(int level, char *logmessage); 
+	void (*informational)(int level, char *logmessage);
+#ifdef DEBUG
+	void (*debug)(int level, char *logmessage);
+#endif
+} log_t;
+
+void log_init(void);
+void log_link(int level, int output);
+void log_message(int level, char *message, ...);
+void log_error(char *functionname);
+
+char *my_vasprintf(const char *fmt, va_list ap);
+
+#endif
diff -Naur bitlbee-20031229/nick.c bitlbee-20031229-daemon/nick.c
--- bitlbee-20031229/nick.c	2003-12-25 13:03:47.000000000 +0100
+++ bitlbee-20031229-daemon/nick.c	2003-12-29 14:47:28.000000000 +0100
@@ -43,9 +43,9 @@
 	}
 	
 	if( m )
-		n = m->next = malloc( sizeof( nick_t ) );
+		n = m->next = bitlbee_alloc( sizeof( nick_t ) );
 	else
-		n = irc->nicks = malloc( sizeof( nick_t ) );
+		n = irc->nicks = bitlbee_alloc( sizeof( nick_t ) );
 	memset( n, 0, sizeof( nick_t ) );
 	
 	n->handle = strdup( handle );
diff -Naur bitlbee-20031229/protocols/nogaim.c bitlbee-20031229-daemon/protocols/nogaim.c
--- bitlbee-20031229/protocols/nogaim.c	2003-12-03 16:49:22.000000000 +0100
+++ bitlbee-20031229-daemon/protocols/nogaim.c	2003-12-29 14:47:28.000000000 +0100
@@ -51,8 +51,6 @@
 };
 static char *proto_away_alias_find( GList *gcm, char *away );
 
-static char *set_eval_away_devoice( irc_t *irc, set_t *set, char *value );
-
 static int remove_chat_buddy_silent( struct conversation *b, char *handle );
 
 GSList *connections;
@@ -62,39 +60,26 @@
 
 void nogaim_init()
 {
-	proto_prpl[PROTO_MSN] = malloc( sizeof( struct prpl ) );
+	proto_prpl[PROTO_MSN] = bitlbee_alloc( sizeof( struct prpl ) );
 	memset( proto_prpl[PROTO_MSN], 0, sizeof( struct prpl ) );
 #ifdef WITH_MSN
 	msn_init( proto_prpl[PROTO_MSN] );
 #endif
-
-	proto_prpl[PROTO_OSCAR] = malloc( sizeof( struct prpl ) );
+	proto_prpl[PROTO_OSCAR] = bitlbee_alloc( sizeof( struct prpl ) );
 	memset( proto_prpl[PROTO_OSCAR], 0, sizeof( struct prpl ) );
 #ifdef WITH_OSCAR
 	oscar_init( proto_prpl[PROTO_OSCAR] );
-#endif
-	
-	proto_prpl[PROTO_YAHOO] = malloc( sizeof( struct prpl ) );
+#endif	
+	proto_prpl[PROTO_YAHOO] = bitlbee_alloc( sizeof( struct prpl ) );
 	memset( proto_prpl[PROTO_YAHOO], 0, sizeof( struct prpl ) );
 #ifdef WITH_YAHOO
 	yahoo_init( proto_prpl[PROTO_YAHOO] );
-#endif
-	
-	proto_prpl[PROTO_JABBER] = malloc( sizeof( struct prpl ) );
+#endif 	
+	proto_prpl[PROTO_JABBER] = bitlbee_alloc( sizeof( struct prpl ) );
 	memset( proto_prpl[PROTO_JABBER], 0, sizeof( struct prpl ) );
 #ifdef WITH_JABBER
 	jabber_init( proto_prpl[PROTO_JABBER] );
 #endif
-	
-	set_add( IRC, "html", "nostrip", NULL );
-	set_add( IRC, "typing_notice", "false", set_eval_bool );
-	set_add( IRC, "away_devoice", "true", set_eval_away_devoice );
-#ifdef ICONV
-	set_add( IRC, "charset", "none", set_eval_charset );
-#endif
-	set_add( IRC, "handle_unknown", "root", NULL );
-	set_add( IRC, "auto_reconnect", "false", set_eval_bool );
-	set_add( IRC, "reconnect_delay", "300", set_eval_int );
 }
 
 struct gaim_connection *gc_nr( int i )
@@ -230,7 +215,7 @@
 	struct gaim_connection *gc;
 	account_t *a;
 	
-	gc = malloc( sizeof( struct gaim_connection ) );
+	gc = bitlbee_alloc( sizeof( struct gaim_connection ) );
 	memset( gc, 0, sizeof( struct gaim_connection ) );
 	
 	gc->protocol = user->protocol;
@@ -409,11 +394,11 @@
 	if( q )
 	{
 		while( q->next ) q = q->next;
-		q = q->next = malloc( sizeof( query_t ) );
+		q = q->next = bitlbee_alloc( sizeof( query_t ) );
 	}
 	else
 	{
-		IRC->queries = q = malloc( sizeof( query_t ) );
+		IRC->queries = q = bitlbee_alloc( sizeof( query_t ) );
 	}
 	memset( q, 0, sizeof( query_t ) );
 	
@@ -788,17 +773,17 @@
 	if( gc->conversations )
 	{
 		for( c = gc->conversations; c->next; c = c->next );
-		c = c->next = malloc( sizeof( struct conversation ) );
+		c = c->next = bitlbee_alloc( sizeof( struct conversation ) );
 	}
 	else
-		gc->conversations = c = malloc( sizeof( struct conversation ) );
+		gc->conversations = c = bitlbee_alloc( sizeof( struct conversation ) );
 	
 	memset( c, 0, sizeof( struct conversation ) );
 	c->id = id;
 	c->gc = gc;
 	c->title = strdup( handle );
 	
-	s = malloc( 16 );
+	s = bitlbee_alloc( 16 );
 	sprintf( s, "#chat_%03d", gc->irc->c_id++ );
 	c->channel = strdup( s );
 	free( s );
@@ -929,7 +914,7 @@
 	return( NULL );
 }
 
-static char *set_eval_away_devoice( irc_t *irc, set_t *set, char *value )
+char *set_eval_away_devoice( irc_t *irc, set_t *set, char *value )
 {
 	int st;
 	
diff -Naur bitlbee-20031229/protocols/nogaim.h bitlbee-20031229-daemon/protocols/nogaim.h
--- bitlbee-20031229/protocols/nogaim.h	2003-12-03 15:07:05.000000000 +0100
+++ bitlbee-20031229-daemon/protocols/nogaim.h	2003-12-29 14:52:01.000000000 +0100
@@ -273,6 +273,7 @@
 void nogaim_init();
 struct gaim_connection *gc_nr( int i );
 int proto_away( struct gaim_connection *gc, char *away );
+char *set_eval_away_devoice( irc_t *irc, set_t *set, char *value );
 int handle_cmp( char *a, char *b, int protocol );
 
 gboolean auto_reconnect( gpointer data );
diff -Naur bitlbee-20031229/set.c bitlbee-20031229-daemon/set.c
--- bitlbee-20031229/set.c	2003-04-28 19:18:55.000000000 +0200
+++ bitlbee-20031229-daemon/set.c	2003-12-29 14:47:28.000000000 +0100
@@ -176,3 +176,46 @@
 		return( value );
 	return( set_eval_int( irc, set, value ) );
 }
+
+char *set_eval_to_char( irc_t *irc, set_t *set, char *value )
+{
+	char *s = bitlbee_alloc( 3 );
+	
+	if( *value == ' ' )
+		strcpy( s, " " );
+	else
+		sprintf( s, "%c ", *value );
+	
+	return( s );
+}
+
+char *set_eval_ops( irc_t *irc, set_t *set, char *value )
+{
+	if( strcasecmp( value, "user" ) == 0 )
+	{
+		irc_write( irc, ":%s!%s@%s MODE %s %s %s %s", irc->mynick, irc->mynick, irc->myhost,
+		                                              irc->channel, "+o-o", irc->nick, irc->mynick );
+		return( value );
+	}
+	else if( strcasecmp( value, "root" ) == 0 )
+	{
+		irc_write( irc, ":%s!%s@%s MODE %s %s %s %s", irc->mynick, irc->mynick, irc->myhost,
+		                                              irc->channel, "-o+o", irc->nick, irc->mynick );
+		return( value );
+	}
+	else if( strcasecmp( value, "both" ) == 0 )
+	{
+		irc_write( irc, ":%s!%s@%s MODE %s %s %s %s", irc->mynick, irc->mynick, irc->myhost,
+		                                              irc->channel, "+oo", irc->nick, irc->mynick );
+		return( value );
+	}
+	else if( strcasecmp( value, "none" ) == 0 )
+	{
+		irc_write( irc, ":%s!%s@%s MODE %s %s %s %s", irc->mynick, irc->mynick, irc->myhost,
+		                                              irc->channel, "-oo", irc->nick, irc->mynick );
+		return( value );
+	}
+	
+	return( NULL );
+}
+
diff -Naur bitlbee-20031229/set.h bitlbee-20031229-daemon/set.h
--- bitlbee-20031229/set.h	2003-06-28 15:08:15.000000000 +0200
+++ bitlbee-20031229-daemon/set.h	2003-12-29 14:47:28.000000000 +0100
@@ -43,5 +43,10 @@
 int set_setstr( irc_t *irc, char *key, char *value );
 int set_setint( irc_t *irc, char *key, int value );
 void set_del( irc_t *irc, char *key );
+
 char *set_eval_int( irc_t *irc, set_t *set, char *value );
 char *set_eval_bool( irc_t *irc, set_t *set, char *value );
+char *set_eval_to_char( irc_t *irc, set_t *set, char *value );
+char *set_eval_ops( irc_t *irc, set_t *set, char *value );
+
+
diff -Naur bitlbee-20031229/user.c bitlbee-20031229-daemon/user.c
--- bitlbee-20031229/user.c	2003-12-03 15:04:47.000000000 +0100
+++ bitlbee-20031229-daemon/user.c	2003-12-29 14:47:28.000000000 +0100
@@ -41,12 +41,12 @@
 			else
 				break;
 		}
-		u->next = malloc( sizeof( user_t ) );
+		u->next = bitlbee_alloc( sizeof( user_t ) );
 		u = u->next;
 	}
 	else
 	{
-		irc->users = u = malloc( sizeof( user_t ) );
+		irc->users = u = bitlbee_alloc( sizeof( user_t ) );
 	}
 	memset( u, 0, sizeof( user_t ) );
 	
